#!/usr/bin/env python3
"""
Universal Unattend.xml Configuration Applier
Reads any XML generated by Unattend Generator and applies settings dynamically
"""

import xml.etree.ElementTree as ET
import subprocess
import winreg
import os
import sys
import tempfile
import re
from pathlib import Path
from urllib.parse import parse_qs, urlparse

class UnattendApplier:
    def __init__(self, xml_path):
        self.xml_path = xml_path
        self.tree = ET.parse(xml_path)
        self.root = self.tree.getroot()
        self.ns = {
            'unattend': 'urn:schemas-microsoft-com:unattend',
            'wcm': 'http://schemas.microsoft.com/WMIConfig/2002/State',
            'ext': 'https://schneegans.de/windows/unattend-generator/'
        }
        self.config = self.parse_url_config()
        
    def is_admin(self):
        """Check if running as administrator"""
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except:
            return False
    
    def parse_url_config(self):
        """Extract settings from URL in XML comment"""
        try:
            # Read the first comment from file
            with open(self.xml_path, 'r', encoding='utf-8') as f:
                content = f.read()
                match = re.search(r'<!--(.+?)-->', content, re.DOTALL)
                if match:
                    comment = match.group(1)
                    if 'schneegans.de' in comment:
                        parsed = urlparse(comment.strip())
                        params = parse_qs(parsed.query)
                        # Convert single-element lists to unique values
                        return {k: v[0] if len(v) == 1 else v for k, v in params.items()}
        except Exception as e:
            print(f"Warning: Could not extract settings from URL: {e}")
        
        return {}
    
    def run_powershell(self, script):
        """Execute PowerShell script"""
        try:
            result = subprocess.run(
                ['powershell', '-ExecutionPolicy', 'Bypass', '-NoProfile', '-Command', script],
                capture_output=True,
                text=True,
                timeout=300
            )
            return result.returncode == 0, result.stdout, result.stderr
        except Exception as e:
            return False, "", str(e)
    
    def apply_registry_file(self, reg_content):
        """Apply .reg file"""
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.reg', delete=False, encoding='utf-16-le') as f:
                f.write('\ufeff')  # BOM for UTF-16 LE
                f.write(reg_content)
                temp_path = f.name
            
            result = subprocess.run(['reg.exe', 'import', temp_path], capture_output=True)
            os.unlink(temp_path)
            return result.returncode == 0
        except Exception as e:
            print(f"‚úó Error applying registry: {e}")
            return False
    
    def extract_embedded_files(self):
        """Extract all embedded files/scripts from XML"""
        files = {}
        file_elements = self.root.findall('.//ext:File', self.ns)
        
        for file_elem in file_elements:
            path = file_elem.get('path')
            content = file_elem.text.strip() if file_elem.text else ""
            # Decode HTML entities
            content = content.replace('&amp;', '&').replace('&lt;', '<').replace('&gt;', '>')
            files[path] = content
            
        return files
    
    def execute_powershell_scripts(self, files):
        """Execute embedded PowerShell scripts"""
        ps1_files = {k: v for k, v in files.items() if k.endswith('.ps1')}
        
        if not ps1_files:
            return
        
        print(f"\n Executing {len(ps1_files)} PowerShell scripts...")
        
        for path, content in ps1_files.items():
            filename = Path(path).name
            print(f"\n Running: {filename}")
            
            success, output, error = self.run_powershell(content)
            
            if success:
                print(f"  ‚úì {filename} executed successfully")
                if output.strip():
                    for line in output.strip().split('\n')[:5]:  # First 5 lines
                        print(f"    {line}")
            else:
                print(f"  ‚úó Error executing {filename}")
                if error:
                    print(f"    {error[:200]}")
    
    def apply_registry_scripts(self, files):
        """Apply embedded .reg files"""
        reg_files = {k: v for k, v in files.items() if k.endswith('.reg')}
        
        if not reg_files:
            return
        
        print(f"\nApplying {len(reg_files)} registry files...")
        
        for path, content in reg_files.items():
            filename = Path(path).name
            success = self.apply_registry_file(content)
            status = "‚úì" if success else "‚úó"
            print(f"  {status} {filename}")
    
    def get_packages_to_remove(self):
        """Extract list of packages to remove from RemovePackages.ps1 script"""
        files = self.extract_embedded_files()
        remove_script = files.get('C:\\Windows\\Setup\\Scripts\\RemovePackages.ps1', '')
        
        if not remove_script:
            # Fallback: use URL config
            packages = []
            for key, value in self.config.items():
                if key.startswith('Remove') and value == 'true':
                    # Convert RemoveOneDrive -> OneDrive
                    pkg_name = key.replace('Remove', '')
                    packages.append(pkg_name)
            return packages
        
        # Extract selectors from script
        matches = re.findall(r"'([^']+)'", remove_script)
        return [m for m in matches if 'Microsoft' in m or 'Clipchamp' in m]
    
    def get_capabilities_to_remove(self):
        """Extract capabilities to remove"""
        files = self.extract_embedded_files()
        remove_script = files.get('C:\\Windows\\Setup\\Scripts\\RemoveCapabilities.ps1', '')
        
        if remove_script:
            matches = re.findall(r"'([^']+)'", remove_script)
            return matches
        return []
    
    def get_features_to_remove(self):
        """Extract features to remove"""
        files = self.extract_embedded_files()
        remove_script = files.get('C:\\Windows\\Setup\\Scripts\\RemoveFeatures.ps1', '')
        
        if remove_script:
            matches = re.findall(r"'([^']+)'", remove_script)
            return matches
        return []
    
    def remove_packages(self):
        """Remove AppX packages dynamically"""
        packages = self.get_packages_to_remove()
        
        if not packages:
            print("\n‚è≠ No AppX packages to remove")
            return
        
        print(f"\nRemoving {len(packages)} AppX packages...")
        
        for pkg in packages:
            cmd = f"Get-AppxPackage -AllUsers | Where-Object {{$_.Name -like '*{pkg}*'}} | Remove-AppxPackage -AllUsers -ErrorAction SilentlyContinue"
            success, _, _ = self.run_powershell(cmd)
            status = "‚úì" if success else "‚óã"
            print(f"  {status} {pkg}")
    
    def remove_capabilities(self):
        """Remove capabilities dynamically"""
        capabilities = self.get_capabilities_to_remove()
        
        if not capabilities:
            print("\n‚è≠No capabilities to remove")
            return
        
        print(f"\nüîå Removing {len(capabilities)} capabilities...")
        
        for cap in capabilities:
            cmd = f"Get-WindowsCapability -Online | Where-Object {{$_.Name -like '*{cap}*' -and $_.State -ne 'NotPresent'}} | Remove-WindowsCapability -Online -ErrorAction SilentlyContinue"
            success, _, _ = self.run_powershell(cmd)
            status = "‚úì" if success else "‚óã"
            print(f"  {status} {cap}")
    
    def remove_features(self):
        """Remove features dynamically"""
        features = self.get_features_to_remove()
        
        if not features:
            print("\n‚è≠No features to remove")
            return
        
        print(f"\nRemoving {len(features)} features...")
        
        for feat in features:
            cmd = f"Get-WindowsOptionalFeature -Online | Where-Object {{$_.FeatureName -eq '{feat}' -and $_.State -ne 'Disabled'}} | Disable-WindowsOptionalFeature -Online -Remove -NoRestart -ErrorAction SilentlyContinue"
            success, _, _ = self.run_powershell(cmd)
            status = "‚úì" if success else "‚óã"
            print(f"  {status} {feat}")
    
    def restart_explorer(self):
        """Restart Windows Explorer"""
        print("\nRestarting Windows Explorer...")
        script = "Stop-Process -Name explorer -Force -ErrorAction SilentlyContinue"
        self.run_powershell(script)
        print("  ‚úì Explorer restarted")
    
    def apply_all(self):
        """Apply all settings found in XML"""
        if not self.is_admin():
            print("This script must be run as Administrator!")
            print("   Right-click and select 'Run as administrator'")
            return False
        
        print("=" * 70)
        print("   UNIVERSAL UNATTEND.XML CONFIGURATION APPLIER")
        print("=" * 70)
        print(f"File: {self.xml_path}")
        
        # Show information about what will be applied
        files = self.extract_embedded_files()
        print(f"\nConfiguration found:")
        print(f"   ‚Ä¢ PowerShell Scripts: {len([f for f in files if f.endswith('.ps1')])}")
        print(f"   ‚Ä¢ Registry Files: {len([f for f in files if f.endswith('.reg')])}")
        print(f"   ‚Ä¢ Packages to remove: {len(self.get_packages_to_remove())}")
        print(f"   ‚Ä¢ Capabilities to remove: {len(self.get_capabilities_to_remove())}")
        print(f"   ‚Ä¢ Features to remove: {len(self.get_features_to_remove())}")
        
        print("\nWARNING: This process will modify system settings!")
        print("   Press CTRL+C in the next 5 seconds to cancel...\n")
        
        import time
        for i in range(5, 0, -1):
            print(f"   Starting in {i}...", end='\r')
            time.sleep(1)
        print(" " * 50)
        
        try:
            # Execute in correct order
            self.remove_packages()
            self.remove_capabilities()
            self.remove_features()
            self.apply_registry_scripts(files)
            self.execute_powershell_scripts(files)
            self.restart_explorer()
            
            print("\n" + "=" * 70)
            print("SETTINGS APPLIED SUCCESSFULLY!")
            print("=" * 70)
            print("\nTip: Restart your computer to ensure all")
            print("   changes take effect.\n")
            
            return True
            
        except KeyboardInterrupt:
            print("\n\nOperation cancelled by user!")
            return False
        except Exception as e:
            print(f"\n\nError during application: {e}")
            import traceback
            traceback.print_exc()
            return False

def main():
    print("\nUniversal Unattend.xml Configuration Applier\n")
    
    if len(sys.argv) < 2:
        print("Usage: python unattend_applier.py <path_to_autounattend.xml>")
        print("\nExample:")
        print("  python unattend_applier.py autounattend.xml")
        print("  python unattend_applier.py C:\\Downloads\\my_config.xml")
        sys.exit(1)
    
    xml_path = sys.argv[1]
    
    if not os.path.exists(xml_path):
        print(f"File not found: {xml_path}")
        sys.exit(1)
    
    applier = UnattendApplier(xml_path)
    success = applier.apply_all()
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()